\documentclass[12pt]{report}
\usepackage{graphicx}
\usepackage[utf8]{vietnam}
\usepackage[left=3cm, right=3cm, top=3cm, bottom =3cm]{geometry}
\usepackage{pdfpages}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{etoolbox}

% \setcounter{tocdepth}{4}

% Link color setup
\hypersetup{
	colorlinks = true,
	linkcolor = black,
	citecolor = blue
}

% Change format of page
\pagestyle{fancy}
\fancyhf{}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{Kỹ thuật lập trình}
\fancyfoot[L]{Nhóm 6 - KSTN-CNTT-K60}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{}

\renewcommand{\thesection}{\Roman{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}

% format
\usepackage{titlesec}
\usepackage{etoolbox}
\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}
\patchcmd{\ttlh@hang}{\noindent}{}{}{}
\makeatother

\titleformat{\subsection}
{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\normalsize\sffamily\bfseries}{\thesubsubsection}{1em}{}


% PYTHON
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\sffamily\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\sffamily\bfseries\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\sffamily\ttb\color{deepred},    % Custom highlighting style
stringstyle=\sffamily\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false ,        % 
tabsize = 4
}}

% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}
% END PYTHON

\patchcmd{\abstract}{LỜI NÓI ĐẦU}{Summary}{}{}


\begin{document}

\includepdf{title.pdf}
\newpage
\setcounter{page}{1}
\begin{center}
\LARGE\bfseries LỜI NÓI ĐẦU
\end{center}

Lập trình là một công việc ngày càng trở nên phổ biến và quan trọng đối với những người làm việc trong lĩnh vực công nghệ nói chung. Việc viết được một chương trình để mô phỏng lại một số thao tác hữu hạn các bước mà máy tính phải làm, chẳng qua là việc sử dụng ngôn ngữ lập trình để tạo nên một dãy các câu lệnh yêu cầu các thao tác tương ứng của máy tính để đáp ứng được mục đích đề ra ban đầu của người lập trình không phải là một công việc quá khó. Cũng như việc giao tiếp hằng ngày giữa con người với nhau, chúng ta chỉ cần biết cách dùng từ, biết một chút ngữ pháp, là có thể giúp được đối phương hiểu được điều ta muốn truyền đạt. Tuy nhiên, giao tiếp thì có Nghệ Thuật Giao Tiếp, và cũng thế, lập trình phải có Kỹ Thuật Lập Trình. Nếu giao tiếp tốt là một yếu tố quyết định thành công của nhiều người, thì Kỹ Thuật Lập Trình cũng là một trong những yếu tố đánh giá được trình độ của người lập trình viên. Lập trình cũng có nghệ thuật, kỹ thuật cũng có nét đẹp riêng của nó. 

Ngôn ngữ lập trình hiện nay rất đa dạng, rất nhiều những ngôn ngữ với những thế mạnh riêng được sử dụng. Tuy nhiên chung quy lại, công việc lập trình vẫn luôn tuân theo những quy tắc nhất định. Và luôn tồn tại những chuẩn mực chung trong việc sử dụng và bố trí những câu lệnh sao cho chương trình của chúng ta ngắn gọn, dễ hiểu, dễ phân tích, dễ tìm kiếm, dễ phát triển,... Nắm được những chuẩn mực đó, sẽ không còn là vấn đề trong việc cố gắng biến những ý tưởng, thuật toán thành những chương trình cho dù bạn được yêu cầu phải sử dụng ngôn ngữ gì đi chăng nữa!

Từ yêu cầu thực tiễn đó, nhóm chúng em xin tổng hợp lại một số nguyên tắc, cũng như kinh nghiệm của các chuyên gia nổi tiếng thể giới về công nghệ thông tin. Tài liệu sử dụng gồm có Steve McConnell. Code Complete, Second Edition ; Publisher: Microsoft Press; Pub Date: une 09, 2004; Print ISBN: 0-7356-1967-0; Pages: 960. Và bài giảng Introduction to Computer Science and Programming in Python tại https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001 \\
-introduction-to-computer-science-and-programming-in-python-fall2016/index.htm của trường đại học MIT. Cùng với sự kết hợp ăn ý và phân chia công việc hợp lý, cả nhóm đã hoàn thành bản báo cáo với tất cả tâm huyết và đam mê nghiên cứu. Xin được gửi lời cảm ơn chân thành đến Thầy Huỳnh Quyết Thắng, giảng viên khoa Công nghệ phần mềm. Trường Đại học Bách Khoa Hà Nội – đã hết lòng giúp đỡ, hướng dẫn, chỉ dạy tận tình để nhóm em có thể hoàn thành được đề tài này.

Vì đây là một trong những bản báo cáo đầu tiên mà nhóm thực hiện nên không thể tránh khỏi sai sót, rất mong được nhận mọi ý kiên góp ý từ thầy cô và các bạn. 

Xin chân thành cảm ơn!
\newpage 

\tableofcontents 
\newpage 

\section{\bfseries Tổng hợp kỹ thuật viết mã nguồn với các cấu trúc lập trình}

\subsection{Sử dụng chương 14 – Tổ chức các câu lệnh tuần tự.}
\noindent Các kỹ thuật tiêu biểu gồm: 

\subsubsection{KT 14.1. The strongest principle for organizing straight-line code is ordering dependencies.}
Nguyên tắc mạnh nhất trong tổ chức câu lệnh tuần tự là phụ thuộc tuần tự.
\begin{itemize}
	\item Những câu lệnh có quan hệ trực tiếp lẫn nhau được nhóm vào thành một khối.
	\item Viết code để đọc từ trên xuống .
	\item Sự phụ thuộc giữa các dòng lệnh phải được tổ chức rõ ràng.
\end{itemize}
Ví dụ trong insertion sort:
\begin{python}
def insertion_sort(a, n):
	for i in range(0, n):
		for j in range(i, n):
			if a[i] > a[j]:
				x = a[i]
				a[i] = a[j]
				a[j] = x
	print("\nDay sau khi sap xep: ")
	print(a)

sophantu = input("\nNhap so phan tu: ")
sophantu = int(sophantu)
b = []
for i in range(0, sophantu):
	alpha = int(input("a[" + str(i) + "] = "))
	b.append(alpha)
insertion_sort(b, sophantu)
\end{python}

\subsubsection{KT 14.2. Dependencies should be made obvious through the use of good routine names, parameter lists, comments, and—if the code is critical enough—housekeeping variables.}
Sự phụ thuộc giữa các câu lệnh nên được thể hiện rõ qua việc đặt tên thủ tục, danh sách tham số, chú thích, và có đủ các biến housekeeping để kiểm tra thứ tự phụ thuộc của các thành phần critical của mã.
\begin{itemize}
	\item Đặt tên chương trình để câu lệnh là rõ ràng.
	\item Tổ chức code để câu lệnh rõ ràng.
	\item Sử dụng thông số để câu lệnh rõ ràng.
\end{itemize}
Ví dụ trong Check Prime Number:

\begin{python}
import math

def CheckPrime(a):
	if a < 2: return 0
	elif a == 2: return 1
	elif a == 3: return 1
	else:
		for i in range(2, int(math.sqrt(a) + 1)):
			if a % i == 0: return 0
			else: return 1

a = int(input('a = '))
if CheckPrime(a) == 1:
	print('a la so nguyen to')
else:
	print('a khong la so nguyent to')
\end{python}


\subsubsection{KT 14.3. If code doesn't have order dependencies, keep related statements as close together as possible.}
Nếu đoạn mã không có phụ thuộc theo thứ tự, các câu lệnh có liên quan với nhau nên được đặt gần nhau nhất có thể.
\begin{itemize}
	\item Tạo code để đọc từ trên xuống dưới. Tránh rẽ nhánh và vòng vo.
	\item Gom những biến liên quan lại và cố gắng đặt chúng gần nhau.
	\item Giảm thiểu thời gian sống của biến, đồng thời rút ngắn tối đa khoảng cách giữa các tham chiếu trên cùng một đối tượng. Điều này làm giảm cơ hội của lỗi khởi tạo, tăng khả năng phát hiện các đối tượng cần tìm kiếm.
	\item Gom những ý liên quan một cách logic. Nếu câu lệnh liên quan về dữ liệu hay mục đích, giữ chúng gần nhau nhất có thể.
\end{itemize}

Ví dụ trong phần CheckPrime: 
\begin{python}
def CheckPrime(a):
	if a < 2: return 0
	elif a == 2: return 1
	elif a == 3: return 1
	else:
		for i in range(2, int(math.sqrt(a) + 1)):
			if a % i == 0: return 0
			else: return 1
\end{python}

\subsection{Sử dụng chương 15 – Sử dụng câu lệnh If-Then}
\noindent Các kỹ thuật tiêu biểu gồm: 

\subsubsection{KT 15.1. For simple if-else statements, pay attention to the order of the if and else clauses, especially if they process a lot of errors. Make sure the nominal case is clear.}
Đối với câu đơn if-else, chú ý đến thứ tự của if và else , đặc biệt là nếu chúng xử lý rất nhiều lỗi. Hãy chắc chắn rằng các trường hợp danh nghĩa là rõ ràng. 
\begin{itemize}
	\item Vạch ra đường thực hiện thông thường trước rồi mới đặt câu lệnh điều kiện cho trường hợp bất thường. điều này cần thiết cho việc dễ đọc mã nguồn cũng như thực thi.
	\item Với các câu điều kiện so sánh >, >=, <, <=, hãy đảm bảo khi điều kiện = xảy ra thì rẽ nhánh hợp lí.
	\item Đưa trường hợp ta mong chờ sẽ thực hiện (trường hợp bình thường) sau câu lệnh if hơn là else. Điều này đảm bảo khi ta xem lại code, có thể tìm kiếm nhanh chóng hơn, máy tính thực hiện cũng có thể nhanh hơn trong nhiều trường hợp do không cần xét quá nhiều trường hợp hãn hữu.
	\item Tránh sử dụng câu lệnh if rỗng (null if). Nếu sử dụng, hãy chú thích để người đọc dễ hiểu hơn.
	\item Hãy xem xét các mệnh đề else Nếu bạn nghĩ rằng bạn cần một câu lệnh đơn giản if, hãy cân nhắc xem bạn có cần sử dụng mệnh để else không?
	\item Kiểm tra lại tính đúng đắn của các mệnh đề, điều này là rõ ràng cần thiết.
	\item Kiểm tra sự đảo ngược của lệnh if và else. Rất có thể mệnh đề if và else của bạn bị đảo ngược cho nhau. 
\end{itemize}
Ví dụ thuật toán Bubble Sort:
\begin{python}
#giai phuong trinh bac hai:
import math
def solve_equation(a, b, c):
	if a == 0:
		print('day khong phai phuong trinh bac hai')
	else:
		delta = b*b - 4*a*c
		if delta < 0:
			print('phuong trinh vo nghiem thuc')
		elif delta == 0:
			x = float(-float(b) / (2*a))
			print('phuong trinh co nghiem kep x = ')
			print(x)
		else:
			x1 = float((-b+math.sqrt(delta))/(2*a))
			x2 = float((-b-math.sqrt(delta))/(2*a))
			print('phuong trinh co hai nghiem phan biet x1 = ' 
				str(x1) + 'x2 = ' + str(x2))
\end{python}

\subsubsection{KT 15.2. For if-then-else chains and case statements, choose an order that maximizes read-ability.}
Đối với chuỗi các mệnh đề if-then-else và câu lệnh case, chọn một thứ tự có thể tối đa hóa khả năng đọc.
\begin{itemize}
	\item Sử dụng các hàm thay vì dùng kết hợp các câu lệnh and, or.
	\item Đưa trường hợp mong chờ sẽ được thực hiện nhất lên đầu tiên.
	\item Hãy đảm bảo tất cả các trường hợp đều đã được xem xét.
	\item Nếu ngôn ngữ không hỗ trợ chuỗi lệnh if-then-else thì sử dụng các câu lệnh case và ngược lại.
\end{itemize}

\begin{python}
#giai phuong trinh bac hai:
import math
def solve_equation(a, b, c):
	if a != 0:
		delta = b*b - 4*a*c
		if delta > 0:
            x1 = float((-b + math.sqrt(delta))/(2*a))
			x2 = float((-b - math.sqrt(delta))/(2*a))
			print('phuong trinh co hai nghiem phan biet x1 = ' 
							+ str(x1) + 'x2 = ' + str(x2))
			
		elif delta == 0:
			x = float(-b/(2*a))
			print('phuong trinh co nghiem kep x =')
			print(x)

		else:
			print('phuong trinh vo nghiem thuc')
	else:
		print('day khong phai phuong trinh bac hai')
\end{python}

\subsubsection{KT 15.3. To trap errors, use the default clause in a case statement or the last else in a chain of if-then-else statements.}
Để bẫy lỗi, sử dụng default khi sử dụng lệnh case hoặc else khi sử dụng chuỗi lệnh if – then – else.
\vspace*{3mm}

Lưạ chọn thứ tự các trường hợp để có hiệu quả nhất:
\begin{itemize}
	\item Thứ tự các trường hợp theo bảng chữ cái hoặc số lượng.
	\item Đặt các trường hợp thong thường lên đầu.
	\item Sắp xếp các trường hợp theo xác suất.
\end{itemize}
Ví dụ trong đoạn code sau: 
\begin{python}
s = input('Chon mot trong nhung phuong an A,B,C')
if (s == 'A'):
	dothecaseA()
elif (s == 'B'):
	dothecaseB()
elif (s == 'C'):
	dothecaseC()
else:
	print('Ban da nhap sai, ban phai chon mot trong nhung' +
		' phuong an A,B,C')
\end{python}


\subsubsection{KT 15.4. All control constructs are not created equal. Choose the control construct that's most appropriate for each section of code.}
Tất cả các cấu trúc điều khiển không được tạo ra như nhau. Chọn cấu trúc điều khiển mà là thích hợp nhất cho mỗi phần của mã.
\begin{itemize}
	\item Chỉ sử dụng switch – case cho những trường hợp biến case đơn giản (char, số).
	\item Sử dụng default, else để xử lý các trường hợp không mong muốn.
	\item Python không hỗ trợ lệnh switch-case, cho nên ta buộc phải sử dụng cấu trúc điều khiển if-then-else.
\end{itemize}


\subsection{Sử dụng chương 16 – Vòng lặp}
\noindent Các kỹ thuật tiêu biểu gồm: 

\subsubsection{KT 16.1. Loops are complicated. Keeping them simple helps readers of your code.}
Vòng lặp thì phức tạp. Giữ cho vòng lặp trở nên đơn giản hơn cho người đọc dễ đọc code của bạn hơn.
\vspace*{3mm}

Lựa chọn loại vòng lặp:
\begin{itemize}
	\item Sử dụng biến đếm giúp xác định số lần lặp cụ thể.
	\item Đánh giá một vòng lặp ở thời gian mà vòng lặp sẽ thực hiện, nó sẽ kết thúc sau bao nhiêu vòng lặp hay lặp vô hạn.
	\item Các loại vòng lặp khác nhau thì khác biệt ở vị trí câu lệnh kiểm tra điều kiện kết thúc (vị trí này có thể ở đầu, giữa hoặc ở cuối vòng lặp).
	\item Các loại vòng lặp cũng được phân biệt bằng độ linh hoạt của chúng -> là việc các vòng lặp sẽ chạy trong một số lần nhất định hay phải kiểm tra sự kết thúc sau mỗi chu kì.
	\item Sử dụng linh hoạt vòng lặp while và for.
\end{itemize}
Vòng lặp while: 
\begin{python}
count = 0
while (count < 9):
	print('So thu tu cua ban la: ', count)
	count += 1
\end{python}
Vòng lặp for:
\begin{python}
for letter in 'Python':
	print 'Chu cai hien tai: ', letter
qua = ['chuoi', 'tao', 'xoai']
for q in qua:
	print "Ban co thich an: ", q
\end{python}

\subsubsection{KT16.2. Techniques for keeping loops simple include avoiding exotic kinds of loops, minimizing nesting, making entries and exits clear, and keeping housekeeping code in one place.}
Kĩ thuật để làm cho vòng lặp trở nên đơn giản bao gồm tránh các vòng lặp lạ, tối thiểu các vòng lặp lồng nhau, tạo và thoát vòng lặp một cách rõ ràng, giữ các housekeeping code ở một vị trí.
\vspace*{3mm}

\noindent Minimizing nesting:
\begin{itemize}
	\item Độ dài vòng lặp có thể được tính bởi số dòng của vòng lặp hay số các vòng lặp lồng nhau.
	\item Nên tạo các vòng lặp ngắn sao cho có thể quan sát tất cả vòng lặp trong một lần.
	\item Hạn chế số lượng các vòng lặp lồng nhau ở con số 3.
	\item Nếu vòng lặp dài thì phải thật rõ ràng.
\end{itemize}
Lồng vòng lặp while để in các số nguyên tố nhỏ hơn 100:
\begin{python}
i = 2
while (i < 100):
	j = 2
	while (j <= i / j):
		if i % j == 0:
			break
		j += 1
	if (j > i / j):
		print i, " la so nguyen to"
	i += 1
\end{python}

\noindent Making entries clearly:
\begin{itemize}
	\item Đặt các giá trị khởi tạo cho các biến trong vòng lặp trước khi vào vòng lặp đó.
	\item Truy cập vòng lặp chỉ tại một vị trí. Việc này giúp tránh xảy ra lỗi khi ta copy hoặc di chuyển vòng lặp tới một vị trí khác trong mã nguồn. Hơn nữa, khi kích thước chương trình lớn, việc đặt các lệnh khởi tạo trước vòng lặp giúp cho việc thay đổi nó dễ dàng, nhanh chóng hơn.
	\item Sử dụng vòng lặp while, for cho vòng lặp vô hạn.
\end{itemize}

\noindent Making exits clearly:
\begin{itemize}
	\item Đảm bảo rằng vòng lặp có thể kết thúc.
	\item Tạo điều kiện kết thúc rõ ràng cho vòng lặp.
\end{itemize}
Lặp vô hạn:
\begin{python}
var = 1
while var == 1: 	# lenh nay tao mot vong lap vo han
	num = raw_input("Hay nhap mot so: ")
	print "So da nhap: ", num
\end{python}
Sử dụng $break$ và $continue$ để điều khiển vòng lặp: 
\begin{python}
for letter in 'Python': 	# vi du thu nhat
	if letter == 'h':
		break
	print 'Chu cai hien tai: ', letter

var = 10					# vi du thu hai
while var > 0:
	print 'Gia tri bien hien tai la: ', var
	var = var - 1
	if var == 5:
		break
\end{python}

\begin{python}
for letter in 'Python':     # Vi du thu nhat
   if letter == 'h':
      continue
   print 'Chu cai hien tai :', letter

var = 10                    # Vi du thu hai
while var > 0:              
   var = var -1
   if var == 5:
      continue
   print 'Gia tri bien hien tai la :', var
\end{python}
\noindent Keep housekeeping code in one place:
\begin{itemize}
	\item Housekeeping code là những lệnh như i++, j = j+1,… để điều khiển vòng lặp. Nên đặt các lệnh này ở đầu hoặc cuối vòng lặp.
\end{itemize}

\subsubsection{KT 16.3. Loop indexes are subjected to a great deal of abuse. Name them clearly, and use them for only one purpose.}
Các chỉ số vòng lặp bị lạm dụng rất nhiều. Đặt tên cho chúng thật rõ ràng và chỉ sử dụng cho một mục đích.
\vspace*{3mm}

\noindent Cách dùng các chỉ số vòng lặp:
\begin{itemize}
	\item Dùng biến đếm hoặc biến thứ tự.
	\item Biến đếm nên là số nguyên và không nên là số thực dấu phẩy động.
	\item Sử dụng các tên biến có ý nghĩa khi làm việc với các vòng lặp lồng nhau (thay vì dùng i, j, k,… thì đặt tên có sự gợi nhớ) -> không mắc phải sử dụng nhầm tên biến hay sử dụng một biến nhiều lần.
	\item Hạn chế phạm vi của các biến vòng lặp chỉ trong vòng lặp đó.
\end{itemize}

\subsubsection{KT 16.4.Think through the loop carefully to verify that it operates normally under each case and terminates under all possible conditions.}
Xem xét toàn bộ vòng lặp một cách cẩn thận để kiểm chứng rằng nó đã hoạt động bình thường trong mọi trường hợp và có thể kết thúc dưới mọi điều kiện.
\begin{itemize}
	\item Đảm bảo rằng vòng lặp kết thúc được (bằng cách cho chạy thử một số lần lặp với các giá trị cụ thể, xem xét tất cả các trường hợp có thể xảy ra, các điểm kết thúc, các ngoại lệ).
	\item Viết các điều kiện kết thúc vòng lặp rõ ràng.
	\item Kiểm tra vòng lặp có kết thúc với kết quả như mong muốn hay không.
\end{itemize}


\subsection{Sử dụng chương 17 – Các cấu trúc điều khiển khác}
\noindent Các kỹ thuật tiêu biểu gồm: 

\subsubsection{KT 17.1. Multiple returns can enhance a routine's readability and maintainability, and they help prevent deeply nested logic. They should, nevertheless, be used carefully.}
Chương trình con có nhiều lần trả về có thể nâng cao khả năng đọc và bảo trì của chương trình và giúp ngăn ngừa sai sót trong những đoạn lồng nhau. Dù vậy chúng nên được sử dụng cẩn thận.
\begin{itemize}
	\item Sử dụng $return$ làm chương trình con dễ đọc hơn.
	\item Giúp ngăn chặn việc xảy ra lỗi khi chạy chương trình.
	\item Khi dùng $return$ phải cẩn trọng xem xét hết các trường hợp.
	
\end{itemize}
\begin{python}
def min(x, y):
	if x < y:
		return x
	elif y > x: 
		return y
	else
		return x
\end{python}

\subsubsection{KT17.2. Recursion provides elegant solutions to a small set of problems. Use it carefully, too.}
Một tập các vấn đề nhỏ thì được giải quyết bằng phương pháp đệ quy. Phải sử dụng đệ quy thật cẩn thận.
\begin{itemize}
	\item Thuật toán đệ quy là thuật toán dựa trên phương pháp chia để trị, chia bài toán thành các bài toán con giải quyết các vấn đề nhỏ hơn bằng cách tự gọi đến chính nó với đầu vào kích thước nhỏ hơn.
	\item Sử dụng thuật toán đệ quy là thuận tiện khi các bài toán con dễ xử lý trong khi với các bài toán lớn thì lại phức tạp.
	\item Đệ quy là một trong những cách tiếp cận hiệu quả và đơn giản đối với một bài toán khó, giúp cho người đọc code có thể dễ dàng nắm bắt được ý tưởng của lập trình viên.
\end{itemize}

\noindent Chú ý khi sử dụng đệ quy:
\begin{itemize}
	\item Đảm bảo rằng đệ quy phải có điểm dừng.
	\item Tránh sử dụng đệ quy xoay vòng (ví dụ A gọi B, B gọi C, C gọi A), việc này là nguy hiểm vì dễ dẫn đến chạy vô hạn.
	\item Kiểm soát xem stack đang dùng còn đủ dung lượng không.
	\item Không nên sử dụng đệ quy cho các bài toán có thể giải quyết dễ dàng bằng vòng lặp nói chung (ví dụ như bài toán tính giai thừa, tìm số Fibonaci,…).
\end{itemize}
\begin{python}
def factorial(n):
	if n == 0 or n == 1:
		return 1
	else 
		return n * factorial(n - 1)
\end{python}


\subsubsection{KT17.3. In a few cases, gotos are the best way to write code that's readable and maintainable. Such cases are rare. Use gotos only as a last resort.}
Trong một số ít trường hợp, lệnh goto là cách tốt nhất để viết code trở nên dễ đọc và dễ bảo trì. Tuy nhiên các trường hợp này rất hiếm khi xảy ra. Việc sử dụng gôt chỉ là phương án cuối cùng.
\begin{itemize}
	\item Goto thường được dùng để xử lý các cấu trúc rẽ nhánh lồng nhau.
	\item Lý do goto không được khuyến khích sử dụng là nó có thể được thay thế bởi các lệnh khác (ví dụ break/continue) hoặc gom phần code mà goto chỉ đến vào trong hàm.
	\item Trong python không hỗ trợ lệnh goto.
\end{itemize}


\section{\bfseries Tổng hợp kỹ thuật làm việc với các biến}

\subsection{Sử dụng chương 10 -- Các kỹ thuật chung làm việc với biến}
\noindent Các kĩ thuật tiêu biểu gồm:
\subsubsection{KT10.1. Data initialization is prone to errors, so use the initialization techniques described in this chapter to avoid the problems caused by unexpected initial values.}
Việc khởi tạo dữ liệu dễ gặp lỗi, sử dụng kĩ thuật mô tả khởi tạo trong phần này để tránh các vấn đề
không mong muốn gây ra bởi giá trị ban đầu.
\vspace*{3mm}

\noindent {\bfseries Kiểu dữ liệu: }
\begin{itemize}
	\item Kiểu số:
	\begin{itemize}
		\item Kiểu int: Kiểu số nguyên có dấu. 
		\item Kiểu long: Kiểu số nguyên giới hạn kích cỡ lớn hơn nhiều kiểu int. 
		\item Kiểu float: Kiểu số thực chấm phẩy động. 
		\item Kiểu số phức: Có dạng a + bi, khai báo trong Python: complex(x, y)
	\end{itemize}	
	
	\item Kiểu string. 
	\item Kiểu list.
	\item Kiểu tuple. 
	\item Kiểu dictionary. 
	\item Kiểu boolean. 		
\end{itemize}
Đầu tiên để tạo dữ liệu có hiệu quả là phải biết loại dữ liệu cần tạo. Trải qua bài kiểm tra các
kiểu dữ liệu sẽ giúp bạn xác định được sự hiểu biết của mình về các kiểu dữ liệu.

\subsubsection{KT10.2. Minimize the scope of each variable. Keep references to a variable close together. Keep it local to a routine or class. Avoid global data.}
Giảm thiểu phạm vi của mỗi biến. Giữ những biến có liên quan ở gần nhau. Giữ trong hàm hoặc
lớp ( biến cục bộ ) . Tránh sử dụng biến toàn cục.
\vspace*{3mm}

Ví dụ bài toán sắp xếp: 
\begin{python}
#string handler 01
def Funtion_XuLiChuoi01(String):
    i=0
    L1=str.split(String)
    a=len(L1)
    for i in range(a):
        if i==0:
            s=L1[a-1]+" "+L1[0]
        if i>0 and i<a-1:
            s=s+" "+L1[i]
    return s
#string handler 02
def Funtion_XuLiChuoi02(String):
    i=0
    L1=str.split(String)
    a=len(L1)
    trungGian=L1[0]
    for i in range(a):
        if i==1:
            s=L1[1]+" ";
        if i>1:
            s=s+" "+L1[i]
    s=s+" "+trungGian
    return s
#sap xep
def Funtion_SapXep(list):
    a=len(list)
    i=0
    L1,L2=[],[]

    for i in range (a):
            L1.append(Funtion_XuLiChuoi01(list[i]))
    L1.sort()
    for i in range (a):
        L2.append(Funtion_XuLiChuoi02(L1[i]))
    return L2
list=["Nguyen Van Trung","Cao Thanh Tung", 	\
		"Tong Van Vinh","Ta Quang Tung"]
print("Ban vua nhap: ",list)
listSapXep=Funtion_SapXep(list)
print(listSapXep)
\end{python}

\subsubsection{KT10.3. Keep statements that work with the same variables as close together as possible.}
Giữ các câu lệnh sử dụng biến chung càng gần nhau càng tốt. \\
Ví dụ giải phương trình bậc 2:
\begin{python}
i = 1
while 1:
    print("Giai phuong trinh bac hai lan ", i)
    a=float(input("Nhap vao a=\n"))
    b=float(input("Nhap vao b=\n"))
    c=float(input("Nhap vao c=\n"))
    if a == 0 :
        if b == 0:
            if c == 0:
                print("Phuong trinh co vo so nghiem")
            else:
                print("Phuong trinh vo nghiem")
        else:
            print("Phuong trinh co nghiem x=",-c/b)
    else:
        denta = b*b - 4*a*c
        if denta < 0:
            x1 = complex(-b/(2*a),math.sqrt(-denta)/(2*a))
            x2 = complex(-b/(2*a),-math.sqrt(-denta)/(2*a))
            print("Phuong trinh co nghiem phuc x1=", x1," va x2=", x2)
        elif denta == 0:
            print("Phuong trinh co nghiem x=",-b / (2*a))
        else:
            x1=(-b + math.sqrt(denta)) / (2*a)
            x2=(-b - math.sqrt(denta)) / (2*a)
            print("Phuong trinh co nghiem x1=",x1," va x2=",x2)
    string=str.lower(input("Nhap no de thoat:\n"))
    if string=="no":
        break
    else:
        i = i + 1
\end{python}
\subsubsection{KT10.4. Early binding tends to limit flexibility but minimize complexity. Late binding tends to increase flexibility but at the price of increased complexity.}
Sự ràng buộc sớm có xu hướng giới hạn tính linh hoạt nhưng giảm bớt sự phức tạp. Sự ràng buộc sau đó có xu hướng tăng tính linh hoạt nhưng cái giá là việc tăng lên của độ phức tạp. 

Thời gian ràng buộc là thời gian mà một biến mà giá trị của nó được được buộc với nhau.  Có phải chúng được buộc với nhau tại thời điểm code được viết? Sau khi được biên dịch? Khi được nạp? Hay khi chương trình chạy?
\vspace*{3mm}

Một vài thời điểm mà giá trị được buộc vào biến: 
\begin{itemize}
	\item Thời điểm viết code (Dành cho những giá trị "magic").
	\item Thời điểm biên dịch (Dành cho những hằng số được đặt tên).
	\item Thời điểm nạp chương trình (Ví dụ như đọc những giá trị từ nguồn bên ngoài chẳng hạn như Windows Registry).
	\item Thời điểm tạo một object.
	\item Chỉ vừa đúng thời điểm (Như là đọc giá trị mỗi lần một cửa sổ được vẽ lên màn hình). 
	\item Liên quan đến việc sử dụng các cấu trúc điều khiển rẽ nhánh và vòng lặp…
\end{itemize}


\subsubsection{KT10.5. Use each variable for one and only one purpose.}
Sử dụng mỗi biến cho duy nhất một mục đích. 

\noindent Ví dụ: Chương trình minh họa biến tên sum dùng để tính tổng các số nguyên từ 1 đến 10
\begin{python}
sum = 0
for i in range(1, 11):
	sum += i
print(sum) 
\end{python}

\subsection{Sử dụng chương 11 -- Kỹ thuật đặt tên biến}
\noindent Các kỹ thuật tiêu biểu gồm:

\subsubsection{KT11.1. Good variable names are a key element of program readability. Specific kinds of variables such as loop indexes and status variables require specific considerations.}
Tên biến tốt là thành phần chính quyết định tính dễ đọc của chương trình. Những loại biến cụ thể như chỉ số trong vòng lặp và những biến trạng thái yêu cầu những xem xét cụ thể hơn. 
\vspace*{3mm}

Ví dụ biến tên:  sql\_request, client\_socket, student\_counter, ... 

\subsubsection{KT11.2. Names should be as specific as possible. Names that are vague enough or general enough to be used for more than one purpose are usually bad names.}
Tên nên cụ thể nhất có thể. Những tên mơ hồ hoặc quá tổng quát sẽ có thể được sử dụng nhiều hơn một mục đích, và thông thường đó là những tên tồi. 
\vspace*{3mm}

Ví dụ: data, a, b, u, count, ... là những tên tồi.

\subsubsection{KT11.3. Naming conventions distinguish among local, class, and global data. They distinguish among type names, named constants, enumerated types, and variables.}
Quy ước đặt tên phải phân biệt giữa biến cục bộ, biến toàn cục và biến trong hàm. Chúng đồng thời cũng phải giúp phân biệt được kiểu dữ liệu, hằng số, kiểu liệt kê, hay là một biến. 
\vspace*{3mm}
\begin{itemize}
	\item Kí tự phải bắt đầu là một dấu “\_ ” hoặc một chữ cái.
	\item Sau kí tự đầu có thể là nhiều kí tự, hoặc nhiều con số.
	\item Python không cho phép sử dụng các kí tự đặc biệt như: @, \#, \$, \%...
	\item Tên class bắt đầu với một  kí tự viết hoa, các định dạng khác là chữ thường. Ví dụ: Person, StudentInfo,...
	\item Nếu đặt tên với việc bắt đầu với một kí tự gạch dưới, ta hiểu rằng đay là một private. Nếu bắt đầu bởi hai kí tự gạch dưới liên tiến, ta hiểu rằng đây là một private mạnh.
	\item Biến đếm ta thường dùng là các chữ cái thường như i,j,k. Chiều dài chuỗi có thể dùng size hoặc length, Hằng thường dùng const, final.
	\item Tránh đặt tên biến, lớp.. trùng với keyword 
\end{itemize}

\subsubsection{KT11.4. Regardless of the kind of project you're working on, you should adopt a variable naming convention. The kind of convention you adopt depends on the size of your program and the number of people working on it.}
Bất kể loại dự án nào mà bạn làm đang làm việc, bạn nên thích thông qua một quy ước đặt tên biến cho dự án đó. Kiểu quy ước nào phụ thuộc vào kích thước chương trình của bạn và số lượng người làm việc với nó. 


\subsubsection{KT11.5. Abbreviations are rarely needed with modern programming languages. If you do use abbreviations, keep track of abbreviations in a project dictionary or use the standardized prefixes approach.}
Viết tắt hiếm khi cần thiết với những ngôn ngữ lập trình hiện đại. Nếu bạn sử dụng từ viết tắt, luôn luôn giám sát chúng bằng cách thêm vào từ điển của dự án hoặc sử dụng một tiền tố đã được chuẩn hoá. 
\vspace*{3mm}

Ví dụ một số tên viết tắt phổ biến: src, dest, info, inc, dec, ...

\subsubsection{KT11.6. Code is read far more times than it is written. Be sure that the names you choose favor read-time convenience over write-time convenience.}
Code được đọc nhiều hơn rất nhiều được viết. Hãy chắc chắn rằng những tên bạn chọn sẽ ủng hộ sự thuận tiện cho thời điểm đọc hơn là thời điểm viết. 


\subsection{Sử dụng chương 12 -- Các kiểu dữ liệu cơ bản}
\noindent Các kĩ thuật tiêu biểu gồm:
\subsubsection{KT12.1. Working with specific data types means remembering many individual rules for each type. Use this chapter's checklist to make sure that you've considered the common problems.}

	Làm việc với những kiểu dữ liệu cụ thể nghĩa là phải nhớ nhiều những quy tắc riêng biệt cho từng kiểu. Như những quy tắc dưới đây:
\begin{itemize}
	\item Kiểu dữ liệu số tổng quát:
		\begin{itemize}
			\item Tránh những "magic number", những hằng số xuất hiện ở giữa code mà không có giải thích
			\item Có thể code trực tiếp 0, 1 nếu cần thiết
			\item Dự tính trường hợp chia cho 0
			\item Tránh so sánh khác kiểu giữ liệu 
			\item Chú ý những cảnh báo của trình dịch 
		\end{itemize}
	\item Kiểu số nguyên:
		\begin{itemize}
			\item Kiểm tra chia nguyên với chia thực 
			\item Kiểm tra tràn số
			\item Kiểm tra tràn số trong các giá trị trung gian
		\end{itemize}
	\item Kiểu số thực chấm phẩy động:
		\begin{itemize}
			\item Tránh cộng và trừ những số có độ lớn khác nhau nhiều
			\item Tránh so sánh bằng 
			\item Dự kiến lỗi làm tròn 
		\end{itemize}
	\item Ký tự và xâu:
		\begin{itemize}
			\item Tránh những ký tự và xâu "magic"
			\item Hiểu rõ ngôn ngữ bạn đang dùng hỗ trợ Unicode ra sao 
			\item Định rõ khu vực, vùng mà chương trình sẽ được sử dụng
			\item Nếu cần hỗ trợ nhiều ngôn ngữ, hãy dùng Unicode 
		\end{itemize}
	\item Biến boolean:
		\begin{itemize}
			\item Sử dụng kiểu boolean để làm rõ những điều kiện trong chương trình 
			\item Sử dụng kiểu boolean để đơn giản hoá những test phức tạp
			\item Tự tạo một kiểu dữ liệu boolean, nếu như cần thiết 
		\end{itemize}
	\item Kiểu enum:
		\begin{itemize}
			\item Sử dụng kiểu enum cho tính dễ đọc 
			\item Sử dụng kiểu enum cho tính tin cậy
			\item Sử dụng kiểu enum để cho việc sửa đổi dễ dàng 
			\item Sử dụng kiểu enum thay thế cho kiểu boolean 
			\item Sử dụng giá trị ban đầu của enum để cho những giá trị không hợp lệ
			\item Xác định rõ phần tử đầu và cuối của enum được sử dụng như thế nào trong toàn bộ project 
			\item Nếu ngôn ngữ không có kiểu enum thì có thể sử dụng class hoặc từ điển  
		\end{itemize}
	\item Hằng số:
		\begin{itemize}
			\item Sử dụng hằng số có đặt tên trong khai báo dữ liệu 
			\item Sử dụng hằng số một cách thống nhất 
		\end{itemize}
	\item Mảng:
		\begin{itemize}
			\item Đảm bảo rằng chỉ số của mảng ở trong miền cho phép 
			\item Luôn nghĩ rằng mảng là một cấu trúc tuần tự 
			\item Nếu mảng là đa chiều, đảm bảo thứ tự của các chỉ số 
			\item Kiểm tra xem chỉ số khi lặp có đúng như mong muốn 
			\item Để thêm một phần tử ở cuối mảng 
		\end{itemize}
\end{itemize}
Ví dụ: 

\begin{python}
EPSILON = 0.0001
def are_same(a, b):
	return abs(a - b) < EPSILON
\end{python}


\subsubsection{KT12.2. Creating your own types makes your programs easier to modify and more self-documenting, if your language supports that capability.}
Tự tạo một kiểu dữ liệu mới sẽ làm cho chương trình dễ dàng sửa đổi và tăng tính tự mô tả, nếu như ngôn ngữ hỗ trợ khả năng này.

\noindent Một số những chỉ dẫn tự tạo một kiểu dữ liệu của mình: 
\begin{itemize}
	\item Tạo kiểu dữ liệu với tên hướng đến chức năng của nó 
	\item Tránh những kiểu dữ liệu đã định nghĩa trước đó 
	\item Đừng định nghĩa kiểu dữ liệu đã được định nghĩa 
	\item Định nghĩa kiểu dữ liệu thay thế cho kiểu dữ liệu cũ để tăng tính khả chuyển 
\end{itemize}
Trong Python không hỗ trợ tạo kiểu dữ liệu mới. 

\subsubsection{KT12.3. When you create a simple type using typedef or its equivalent, consider whether you should be creating a new class instead.}
Nếu tự tạo một kiểu dữ liệu mới bằng typedef hoặc cách tương đương, xem xét việc sử dụng class để thay thế nó.

Ví dụ sử dụng class $StudentID$ để thay thế cho $mssv$ là một số: 
\begin{python}
class StudentID:
	# mssv
	def __init__(self, mssv):
		self.mssv = mssv
\end{python}

\subsection{Sử dụng chương 13 – Các kiểu dữ liệu đặc biệt}
\noindent Các kĩ thuật tiêu biểu gồm:

\subsubsection{KT13.1. Structures can help make programs less complicated, easier to understand, and easier to maintain.}
Kiểu dữ liệu có cấu trúc sẽ giúp chương trình giảm độ phức tạp, dễ dàng để hiểu, để duy trì nó hơn.
 
\noindent Một số những lưu ý khi sử dụng kiểu dữ liệu có cấu trúc: 
\begin{itemize}
	\item Sử dụng kiểu dữ liệu có cấu trúc để làm rõ mối quan hệ giữa các dữ liệu 
	\item Sử dụng để đơn giản hoá những thủ tục lên khối dữ liệu 
	\item Sử dụng để đơn giản hoá tham số đầu vào của hàm 
	\item Sử dụng để giảm bớt việc bảo trì chương trình
\end{itemize}
Ví dụ:
\begin{python}
class Person:
	def __init__(self, name, age, phone):
		self.name = name
		self.age = age
		self.phone = phone

def print_person(person):
	print("Ho ten: " + person.name)
	print("Tuoi: " + person.age)
	print("So dien thoai: " + person.phone)

person = Person("Ta Quang Tung", 19, 123)
print_person(person)
\end{python}

\subsubsection{KT13.2. Whenever you consider using a structure, consider whether a class would work better.}
Khi sử dụng một kiểu giữ liệu có cấu trúc, xem xét liệu rằng class sẽ tốt hơn.

Ví dụ:
\begin{python}
http_request = {'method': 'get', 'url':'sis.hust.edu.vn', \
						'id': 20154280}

def send_http_request(http_request):
	...
\end{python}
Sẽ tốt hơn nếu được thay thế bằng:
\begin{python}
class HttpRequest:
	def __init__(self, method, url, id):
		self.method = method
		self.url = url
		self.id = id
	def send(self):
		...
\end{python}

 
\subsubsection{KT13.3. Pointers are error-prone. Protect yourself by using access routines or classes and defensive-programming practices.}
Con trỏ là kiểu dữ liệu dễ dàng gặp lỗi khi sử dụng. Bảo vệ bản thân bằng việc sử dụng hàm hoặc class khi muốn truy cập nó, hoặc sử dụng kỹ thuật lập trình "tự phòng thủ".
\vspace*{5mm}

\noindent Những yêu cầu khi sử dụng biến con trỏ:
\begin{itemize}
	\item Sử dụng một kiểu con trỏ rõ ràng thay vì kiểu con trỏ mặc định. 
	\item Tránh cast kiểu dữ liệu con trỏ.
	\item Trong C, nếu bạn sử dụng dấu * với tham số ở hàm, luôn nhớ rằng giá trị có thể truyền ngược lại khi gọi hàm. Đồng thời khi bạn muốn truyền ngược lại giá trị, chắc chắn rằng phải có ít nhất một dấu sao trong một câu lệnh gán. 
	\item Sử dụng sizeof() để xác định kích thước của biến khi cấp phát bộ nhớ cho nó. 
\end{itemize}
Trong python không có kiểu con trỏ. 

\subsubsection{KT13.4. Avoid global variables, not just because they're dangerous, but because you can replace them with something better.}
Tránh dử dụng biến toàn cục, không phải chỉ vì nó nguy hiểm mà còn bởi vì bạn có thể thay thế nó bằng những cách thức tốt hơn nhiều. 
\vspace*{5mm}

\noindent Những vấn đề chính khi sử dụng kiểu dữ liệu toàn cục: 
\begin{itemize}
	\item Vô tình thay đổi kiểu dữ liệu toàn cục.
	\item Có thể có những lỗi kì quặc khi sử dụng "tên thay thế" cho biến toàn cục. Chẳng hạn như việc truyền đồng thời tham số vào hàm là biến toàn cục, cũng như sử dụng biến toàn cục trong chính hàm. 
	\item Vấn đề code được sử dụng nhiều lần trong khi nó truy cập đến biến toàn cục, chẳng hạn như lời gọi đệ quy, hoặc trong trường hợp đa luồng. 
	\item Tính tái sử dụng của Code bị cản trở bới kiểu toàn cục. 
	\item Thứ tự khởi tạo không xác định khi sử dụng kiểu toàn cục. 
	\item Tính module hoá và khả năng kiểm soát code bị huỷ hoại bởi sử dụng kiểu toàn cục. 	
\end{itemize}

\noindent Những lý do để sử dụng biến toàn cục: 
\begin{itemize}
	\item Bảo tồn những giá trị toàn cục, ví dụ bảng dữ liệu mà tất cả các hàm sử dụng. 
	\item Liệt kê những giá trị hằng số, trong những ngôn ngữ không hỗ trợ hằng số như Python, Perl. 
	\item Sử dụng như kiểu dữ liệu enum, như trong Python. 
	\item Loại bỏ những dữ liệu "lang thang". Ví dụ như khi có 3 hàm, gọi lần lượt lẫn nhau theo đúng thứ tự 1, 2, 3.
	Hàm 1 và hàm 3 sử dụng cùng một object, nhưng hàm 2 thì không. Nếu truyền qua tham số thì ta vẫn phải truyền nó qua hàm 2, đó là dữ liệu "lang thang". Sử dụng biến toàn cục sẽ loại bỏ những dữ liệu này. 
\end{itemize}

\noindent Sử dụng biến toàn cục chỉ khi nó là phương pháp cuối cùng. 
\begin{itemize}
	\item Bắt đầu bởi tạo một biến cục bộ và chỉ thay đổi nó thành toàn cục khi thực sự cần thiết. 
	\item Phân biệt giữa biến toàn cục và biến trong class. 
	\item Sử dụng những hàm, thủ tục để truy cập.
\end{itemize}

\noindent Làm thế nào để giảm bớt những rủi ro khi sử dụng biến toàn cục:
\begin{itemize}
	\item Triển khai một quy ước đặt tên để làm cho biến toàn cục trở nên hiển nhiên. 
	\item Tạo một danh sách các chú thích tốt cho tất cả các biến toàn cục. 
	\item Đừng sử dụng biến toàn cục cho các kết quả trung gian. 
	\item Đừng giả vờ rằng bạn không sử dụng biến toàn cục bằng cách đặt tất cả dữ liệu vào một object rất lớn và truyền nó khắp mọi nơi. 
\end{itemize}

\subsubsection{KT13.5. If you can't avoid global variables, work with them through access routines. Access routines give you everything that global variables give you, and more.}
Nếu không thể tránh khỏi việc sử dụng biến toàn cục thì nên sử dụng những hàm, thủ tục để truy cập nó thay vì truy cập trực tiếp. 
Truy cập nhờ hàm, thủ tục sẽ cho bạn mọi thứ như khi sử dụng biến đó trực tiếp, và thêm nhiều hơn thế nữa. 
\vspace*{5mm}

\noindent Lợi ích của việc sử dụng hàm truy cập biến toàn cục: 
\begin{itemize}
	\item Bạn có thể tập trung hoá việc truy cập biến toàn cục. Nếu bạn nghĩ ra một cách thức truy cập mới cho dữ liệu đang sử dụng, khi đó bạn không phải thay đổi code nơi mà dữ liệu được sử dụng, chỉ cần thay đổi code trong hàm truy cập. 
	\item Có thể đảm bảo rằng tất cả các truy cập đến biến toàn cục được "rào chắn".
	\item Bạn sẽ được lợi nhờ việc che giấu thông tin tự động. 
	\item Hàm truy cập sẽ giúp dễ dàng cho việc chuyển sang kiểu dữ liệu trừu tượng. 
\end{itemize}

\noindent Làm thế nào để sử dụng hàm truy cập:
\begin{itemize}
	\item Yêu cầu tất cả các truy cập biến phải thông qua hàm truy cập.
	\item Đừng chỉ vứt toàn bộ những biến toàn cục vào một cái thùng. 
	\item Sử dụng cơ chế khoá để bảo vệ biến toàn cục khi lập trình đa luồng. 
	\item Xây dựng thêm một mức trừu tượng hoá vào trong hàm truy cập. 
	\item Giữ tất cả các truy cập của dữ liệu ở cùng một mức trừu tượng, đừng cho phép sử dụng nhiều mức trừu tượng để truy cập giữ liệu. 
\end{itemize}
Ví dụ về hàm truy cập kết hợp cơ chế đồng bộ:
\begin{python}
__counter = 0
__mt = mutex()

def get_counter():
	__mt.lock()
	tmp = __counter
	__mt.unlock()
	return tmp

def set_counter(value):
	__mt.lock()
	__counter = value
	__mt.unlock()
	
def inc_counter():
	__mt.lock()
	__counter += 1
	__mt.unlock()

\end{python}

% Begin section
\section{\bfseries Tổng hợp kỹ thuật xây dựng chương trình, hàm, thủ tục}

\subsection{Sử dụng chương 5 -- Các kỹ thuật thiết kế chương trình phần mềm -- Design in Construction}
\noindent Các kĩ thuật tiêu biểu gồm:

\subsubsection{KT5.1. Software's Primary Technical Imperative is managing complexity. This is greatly aided by a design focus on simplicity.}
Yêu cầu kỹ thuật chính đối với phần mềm là kiểm soát sự phức tạp. Nó được hỗ trợ rất lớn bởi thiết kế tập trung vào sự đơn giản. 
\vspace*{3mm}

\noindent {\bfseries Tầm quan trọng của việc quản lý sự phức tạp trong phát triển phần mềm:}

Khi một cuộc khảo sát về những dự án phần mềm báo cáo nguyên nhân dẫn đến thất bại, họ thường không xác định rõ là những vấn đề về mặt kĩ thuật là nguyên nhân chính gây nên thất bại của dự án. Một dự án thất bại phần lớn bởi vì yêu cầu không rõ ràng, lập kế hoạch không đầy đủ, và kiểm soát kém chặt chẽ. Nhưng khi một dự án thất bại vì lý do chính là kỹ thuật, lý do thường sẽ là không thể kiểm soát được sự phức tạp bên trong phần mềm đó. Phần mềm có thể được phép phát triển đến mức cực kì phức tạp mà không ai có thể hiểu thực sự nó đang làm gì. Khi dự án chạm mức không một ai có thể thực sự hiểu ảnh hưởng của những đoạn code này trong vùng này có tác độngđộng đến đoạn code trong vùng khác như thế nào, sự tiến triển của phần mềm sẽ bị kìm hãm xuống một nửa. 

Kiểm soát sự phức tạp của phần mềm là vấn đề kỹ thuật quan trọng nhất trong phát triển phần mềm.

Sự phức tạp không phải là mới trong công việc phát triển phần mềm. Nhà tiên phong trong khoa học tính toán Edsger Dijkstra đưa ra một luận điểm rằng: tính toán chỉ thực sự chuyên nghiệp khi một bộ óc có trách nhiệm phải mở rộng một dữ liệu từ một bit đến một vài megabyte, một tỉ lệ tầm 1 / $10^9$, hay 9 bậc về độ lớn (Dijkstra 1989). Tỉ lệ đó thật đáng kinh ngạc, Dijkstra đặt nó trong câu nói: "Compared to that number
of semantic levels, the average mathematical theory is almost flat. By evoking
the need for deep conceptual hierarchies, the automatic computer confronts us
with a radically new intellectual challenge that has no precedent in our history." -- Nếu so sánh về số lượng mức ngữ nghĩa, trung bình một lý thuyết toán học gần như bằng phẳng. Bởi việc gợi nên sự cần thiết cho "hệ thống phân cấp khái niệm rất nhiều lớp",  máy tính tự động thách thức chúng ta với một thử thách trí tuệ hoàn toàn mới, cái mà không hề có tiền lệ trong lịch sử. Tất nhiên phần mềm đã ngày càng trở nên phức tạp, và tỉ lệ của  Dijkstra có thể là 1 / $10^{15}$ ngày hôm nay. 

Dijkstra cho rằng không một ai có một bộ óc đủ lớn để chứa đựng một phần mềm máy tính hiện đại, nghĩa là một developer không nên cố gắng nhồi nhét toàn bộ phần mềm vào óc mình tại một thời điểm. Chúng ta phải cố gắng tổ chức chương trình bằng một cách nào đó để tại một thời điểm, ta có thể chỉ cần tập trung vào một phần của chương trình. 


\subsubsection{KT5.2. Simplicity is achieved in two general ways: minimizing the amount of essential complexity that anyone's brain has to deal with at any one time, and keeping accidental complexity from proliferating needlessly.}
\noindent {\bfseries Làm thế nào chống lại sự phức tạp}

Có 3 nguồn của sự tốn kém quá mức, sự thiết kế không hiệu quả:
\begin{itemize}
	\item Một lời giải phức tạp cho một vấn đề đơn giản. 
	\item Một lời giải đơn giản, không chính xác cho một vấn đề phức tạp. 
	\item Một lời giản phức tạp, không hợp lý cho một vấn đề phức tạp. 
\end{itemize}
Như là Dijkstra đã chỉ ra, phần mềm hiện đại bản thân nó là phức tạp, không kể bạn có cố gắng như thế nào, bạn chắc chắn sẽ phải động chạm vào một vài mức của sự phức tạp mà nó là cái vốn có của những vấn đề thực tế. 
Hai cách tiếp cận để kiểm soát sự phức tạp:
\begin{itemize}
	\item Tối thiểu hoá sự phức tạp "thiết yếu" cho bất kì ai phải động đến, tại bất kì thời điểm nào. 
	\item Giữ cho sự phức tạp "tình cờ" tránh khỏi việc trở nên không cần thiết. 
\end{itemize}

\subsubsection{KT5.3. Design is heuristic. Dogmatic adherence to any single methodology hurts creativity and hurts your programs.}
Thiết kế là một công việc heuristic. Bất kì một phương pháp nào tuân thủ theo cách độc đoán, giáo điều sẽ phá hoại sự sáng tạo và phá hoại chương trình của bạn. 
\vspace*{3mm}

\noindent {\bfseries Những thách thức trong thiết kế phần mềm: }
\begin{itemize}
	\item Thiết kế là một "vấn đề mờ" (wicked problem) -- "vấn đề mờ" là những vấn đề mà có thể định nghĩa rõ ràng chỉ khi bởi giải quyết nó, hoặc một phần của nó. Một trong những sự khác biệt giữa chương trình bạn phát triển ở trường và cái mà bạn phát triển khi chuyên nghiệp đó là vấn đề thiết kế được giao ở trường hiếm khi mơ hồ. 
	\item Thiết kế là một quá trình luộm thuộm. Kết quả sau khi hoàn tất thiết kế phần mềm là tổ chức rõ ràng và sạch sẽ. Nhưng quá trình được sử dụng khi phát triển bản thiết kế gần như không "tươm tất" như kết quả cuối cùng. Mắc lỗi là điểm cần thiết của công việc thiết kế. Sự luộm thuộm đến từ việc khó để biết khi nào bản thiết kế của chúng ta đã đủ tốt. Việc thiết kết là một công việc "kết thúc mở", thông thường chỉ kết thúc khi bạn hết thời gian. 
	\item Thiết kế là về việc đánh đổi và sự ưu tiên: Phần chính của một nhà thiết kế là phải đánh giá những đặc tính của phần mềm và cân bằng giữa những đặc tính đó. 
	\item Thiết kế liên quan đến sự hạn chế: Sự ràng buộc trong giới hạn tài nguyên khi xây dựng phần mềm thúc đẩy sự đơn giản hoá trong lời giải, cái mà cuối cùng sẽ cải thiện lời giải của vấn đề. 
	\item Thiết kế là một công việc không xác định: Nếu bạn cho ba người riêng biệt cùng thiết kế một phần mềm, họ chắc chắn sẽ trả về ba bản thiết kế gần như hoàn toàn khác nhau, và có thể tất cả số chúng đều hoàn toàn được chấp nhận. 
	\item Thiết kế là một quá trình heuristic: Bởi vì thiết kế là công việc không xác định, các kỹ thuật thiết kế có xu hướng "heuristic" -- Không bao giờ một phương thức có thể được áp dụng chính xác trong tất cả các trường hợp. Không có công cụ nào là đúng cho mọi thứ. 
	\item Thiết kế là "sự xuất hiện": Thiết kế không phải được hình thành đầy đủ từ bộ óc của một người, nó liên quan và được cải thiện dần dần bởi sự xem xét, sử thảo luận, kinh nghiệm khi viết code hoặc sửa lại code.   
\end{itemize}



\subsubsection{KT5.4. Good design is iterative; the more design possibilities you try, the better your final design will be.}
Một bản thiết kế tốt là quá trình lặp đi lặp lại, càng nhiều những khả năng thiết kế mà bạn thử, kết quả thiết kế cuối cùng của bạn sẽ càng tốt.
\vspace*{3mm}

\noindent {\bfseries Những đặc trưng mong muốn của một bản thiết kế:}
\begin{itemize}
	\item Sự phức tạp tối thiểu. 
	\item Dễ dàng bảo trì. 
	\item Tối thiểu hoá sự kết nối. 
	\item Tính mở rộng. 
	\item Tính tái sử dụng. 
	\item "Lượng đầu vào" cao -- "Lượng đầu vào" ở đây ám chỉ việc một class được các class khác sử dụng như thế nào. "Lượng đầu vào" cao nghĩa là hệ thống phải có các class hữu ích được sử dụng rộng khắp chương trình. 
	\item "Lượng đầu ra" thấp hoặc trung bình -- "Lượng đầu ra" ở đây ám chỉ việc một class sử dụng số class khác bao nhiêu. 
	"Lượng đầu ra" cao (nhiều hơn khoảng 7) chỉ định rằng class đó sử dụng một lượng lớn các class khác, và có thể gây nên sự phức tạp quá mức. 
	\item Tính khả chuyển. 
	\item Sự "nghèo nàn" -- "nghèo nàn" ở đây nghĩa là hệ thống không có những phần dư thừa. 
	\item Sự phân tầng -- Thiết kế hệ thống sao cho bạn có thể nhìn nó ở một mức phân cấp mà không phải đào sâu vào các mức khác. 
	\item Sử dụng những kĩ thuật đã chuẩn hoá.
	 
\end{itemize}
\vspace*{3mm}

\noindent {\bfseries Sự lặp lại trong thiết kế:}

Thiết kế là một quá trình lặp đi lặp lại: Bạn sẽ không chỉ đi từ điểm A đến điểm B, bạn sẽ đi từ điểm A tới B và quay ngược trở lại A. 

Với mỗi lần lặp lại và thử với cách tiếp cận khác nhau, bạn sẽ nhìn vấn đề dưới góc nhìn ở cả mức thấp và mức cao. Bức tranh lớn mà bạn nhận được với những vấn đề ở mức cao sẽ giúp bạn đặt những vấn đề mức thấp ở đúng vị trí. Những chi tiết của vấn đề mức thấp cung cấp cho bạn nền tảng vững chắc cho những quyết định ở mức cao. Hoán đổi việc xem xét giữa mức thấp và mức cao là khá khó khăn, nhưng nó là thiết yếu đối với việc thiết kế hiệu quả. Khi tạo ra bản thiết kế đầu tiên mà có vẻ đủ tốt, đừng nên dừng lại. Nỗ lực lần thứ hai sẽ gần như luôn luôn tốt hơn lần đầu. 


\subsubsection{KT5.5. Information hiding is a particularly valuable concept. Asking "What should I hide?" settles many difficult design issues.}
Ấn giấu thông tin là một khái niệm có giá trị đặc biệt. Luôn luôn đặt câu hỏi "Cái gì tôi nên che giấu?" sẽ giải quyết nhiều những  khó khăn trong vấn đề thiết kế.  
\vspace*{3mm}

\noindent {\bfseries Che giấu thông tin: } \\
Che giấu thông tin là nền tảng của cả thiết kế hướng cấu trúc và hướng đối tượng. Trong thiết kế hướng cấu trúc, khái niệm "hộp đen" đến từ việc che giấu thông tin. Trong thiết kế hướng đối tượng, nó tạo ra những khái niệm đóng gói và module hoá, và nó có liên quan đến khái niệm về sự trừu tượng. 


Bí mật và quyền riêng tư: \\
Trong che giấu thông tin, mỗi class (hoặc một hàm, một package) được đặc trưng bởi những quyết định về thiết kế hoặc xây dựng nó, cái mà nó che giấu từ tất cả những class khác. Vùng bí mật có thể là vùng có khả năng cao sẽ thay đổi, định dạng một file, hay là cách mà dữ liệu được thực hiện, hay những giữ liệu được che chắn cho phần còn lại của chương trình để mà lỗi trong phần này gây nên những hư hại nhỏ cho các phần khác của chương trình. Vai trò của một class là giữ cho những thông tin này ẩn và để bảo vệ nó khỏi những truy cập không mong muốn từ bên ngoài. Một thay đổi nhỏ có thể ảnh hưởng một vài hàm trong class, nhưng nó không nên vượt quá interface của class. 

Một trong những nhiệm vụ chính khi thiết kế một class là quyết định xem những đặc điểm nào sẽ được biết đến bên ngoài class, và những cái nào sẽ được giữ bí mật. Một class có thể có 25 hàm, chỉ có 5 hàm là public, và 20 hàm còn lại chỉ sử dụng với mục đích trong của class. Một class có thể sử dụng một vài kiểu dữ liệu mà không phơi bày bất kì thông tin nào về nó. 

Interface của một class nên tiết lộ ít thông tin nhất có thể về hoạt động bên trong của nó. Thiết kế một interface là một quá trình lặp đi lặp lại như những khía cạnh khác của thiết kế. Nếu bạn không đạt được một interface đúng từ đầu, thử một vài lần cho đến khi nó ổn định. Nếu nó không thể ổn định, bạn cần phải thử một cách tiếp cận khác. 

\noindent {\bfseries Hai dạng của bí mật: }
\begin{itemize}
	\item Ẩn giấu sự phức tạp để mà não của bạn không phải động đến nó trừ khi bạn có quan tâm đặc biệt đến nó. 
	\item Ẩn giấu nguồn gốc của sự thay đổi để mà khi thay đổi xảy ra, nó chỉ ảnh hưởng trong một vùng cục bộ. 
\end{itemize}  
Nguồn gốc của sự phức tạp bao gồm kiểu dữ liệu phức tạp, cấu trúc file, những test đúng sai, liên quan đến thuật toán,...
\vspace*{3mm}

\noindent {\bfseries Những cản trở cho việc che giấu thông tin: }
\begin{itemize}
	\item Sự phân tán quá mức của thông tin. 
	\item Phụ thuộc vòng tròn. 
	\item Không sử dụng class thay cho những biến toàn cục. 
	\item Việc tránh làm giảm hiệu năng của hệ thống. 
\end{itemize}
\vspace*{3mm}

\noindent {\bfseries Giá trị của việc che giấu thông tin: }
Suy nghĩ về việc che giấu thông tin sẽ truyền cảm hứng và nâng cao những lựa chọn khi thiết kế hơn là tư duy hướng đối tượng. 

Việc che giấu thông tin còn hữu dụng trong việc thiết kế public interface của class. Khoảng cách giữa lý thuyết và thực tế trong thiết kế class là lớn, và giữa các người thiết kế class, quyết định thông thường sẽ là interface của class phải thuận tiện để sử dụng nhất có thể. Điều đó thường dẫn đến những thông tin của class bị phơi bày nhiều nhất có thể. 

Luôn đặt câu hỏi "Cái gì của class mà cần che giấu?", đều đó sẽ giúp giảm bớt rất nhiều những vấn đề khi thiết kế interface. Nếu bạn có thể đặt một hàm vào public interface của class mà không gây hại đến tính bí mật của nó thì hãy làm, còn không thì đừng nên. 

Đặt câu hỏi về điều gì bạn cần để ẩn thông tin sẽ hỗ trợ cho việc lựa chọn phương pháp thiết kế ở bất kì một mức nào của phần mềm. Nó đẩy mạnh việc sử dụng những hằng số được đặt tên thay vì những hằng số trực tiếp, nó giúp cho việc tạo ra những tên hàm, tên biến tốt đồng thời hướng dẫn cho việc lựa chọn thiết kế class, các hệ thống con và cách thức liên kết giữa chúng. 

\subsubsection{KT5.6. Lots of useful, interesting information on design is available outside this book. The perspectives presented here are just the tip of the iceberg.}


\subsection{Sử dụng chương 7 -- Kỹ thuật xây dựng hàm/thủ tục High-Quality Routines}
\noindent Các kĩ thuật tiêu biểu gồm:

\subsubsection{KT7.1. The most important reason for creating a routine is to improve the intellectual manageability of a program, and you can create a routine for many other good reasons. Saving space is a minor reason; improved readability, reliability, and modifiability are better reasons.}
Lý do quan trọng nhất để tạo một hàm, thủ tục là để cải thiện khả năng kiểm soát những vấn đề liên quan đến "trí tuệ" của chương trình, và bạn có thể tạo một hàm cho rất nhiều những lý do khác nữa. Tiết kiệm không gian là lý do nhỏ, nâng cao khả năng đọc hiểu, tính tin cậy và khả năng sửa đổi là lý do quan trọng hơn cả.
\vspace*{3mm}

\noindent {\bfseries Những lý do để tạo một hàm, thủ tục: }
\begin{itemize}
	\item Gỉảm bớt sự phức tạp: Tạo một hàm sẽ giúp che giấu thông tin để mà bạn sẽ không cần phải nghĩ về nó. Bạn sẽ phải nghĩ về nó khi viết hàm. Nhưng sau khi nó được tạo ra, bạn có thể quên đi chi tiết về hoạt động bên trong của nó và sử dụng mà không phải lo nghĩ về điều đấy. Lý do khác là để tối thiểu kích thước code, nâng cao khả năng bảo trì, cải thiệt tính đúng đắn của chương trình. Đó cũng là những lý do tốt, nhưng nếu không sức mạnh của tính trừu tượng nhờ việc tạo hàm, một chương trình phức tạp sẽ không thể quản lý được. 
	\item Tạo một vùng code dễ đọc hiểu hơn: Đặt một vùng code vào một hàm đặt tên tốt là cách hợp lý nhất để giải thích mục đích của nó. 
	\item Tránh lặp lại code.
	\item Ẩn giấu thứ tự thực hiện. 
	\item Ẩn giấu các phép toán trên con trỏ. 
	\item Cải thiện tính khả chuyển. 
	\item Đơn giản hoá những test đúng sai phức tạp.
	\item Cải thiện hiệu năng. 
	
\end{itemize}


\subsubsection{KT7.2. Sometimes the operation that most benefits from being put into a routine of its own is a simple one.}
Đôi khi, một phép toán được lợi nhiều nhất từ việc đặt nó vào trong hàm, thủ tục lại là một phép toán đơn giản. 
\vspace*{3mm}

\noindent Xây dựng cả một hàm chỉ chứa một, hai dòng code có thể là quá mức cần thiết. Nhưng kinh nghiệm đã chỉ ra rằng những hàm nhỏ như vậy lại có ích rất nhiều. 

Tạo ra các hàm nhỏ có một vài lợi thế, một trong số đó là cải thiện tính dễ đọc hiểu của code.\\
Ví dụ dòng lệnh:
\begin{python}
points = device_units * (POINT_PER_INCH / device_units_per_inch())
\end{python} 
Có thể khá khó để nhận ra ngày dòng code đó có nghĩa là gì, nhưng nếu viết một hàm như thế này:
\begin{python}
def device_units_to_point(device_units):
	return device_units * (POINT_PER_INCH /  	\
				device_units_per_inch())
\end{python}
Khi đó dòng code trên có thể viết lại thành:
\begin{python}
points = device_units_to_point(device_units)
\end{python}
Code đã trở nên dễ đọc hiểu hơn nhiều. 

Ngoài ra có một lý do khác để đặt một phép toán nhỏ vào trong một hàm: Phép toán nhỏ có xu hướng trở thành một phép toán lớn hơn. 
Giải dụ như trong trường hợp trên $device\_units\_per\_inch()$ trả về giá trị 0, khi đó thay vì sửa lại mỗi dòng code sử dụng nó, ta chỉ cần sửa lại hàm đã viết:
\begin{python}
def device_units_to_point(device_units):
	if device_units_per_inch() != 0:
		return device_units * (POINT_PER_INCH / 	\
					device_units_per_inch())
	else:
		return 0
\end{python}


\subsubsection{KT7.3. You can classify routines into various kinds of cohesion, but you can make most routines functionally cohesive, which is best.}
Bạn có thể phân chia các hàm, thủ tục ra làm nhiều loại gắn kết, nhưng sẽ tốt nhất nếu bạn có thể làm cho hầu hết các hàm "gắn kết theo chức năng".
\vspace*{3mm}

Trong một hàm, sự gắn kết ám chỉ tới việc những phép toán bên trong hàm liên quan đến nhau như thế nào. Một vài lập trình viên sử dụng từ khác là "độ mạnh": Các phép toán trong hàm liên quan đến mạnh như thế nào? 

Có một vài mức của sự gắn kết khi bàn luận về nó trong hàm: 
\begin{itemize}
	\item Sự gắn kết theo chức năng: Là loại gắn kết mạnh nhất, xảy ra khi hàm thực hiện một và chỉ một phép toán. Ví dụ như những hàm $sin()$, $get\_customer\_name()$, $erase\_file()$, $calculate\_loan\_payment()$, and $age\_from\_birthday()$.
	\item Sự gắn kết theo tuần tự: Là loại gắn kết tồn tại khi một hàm, thủ tục tồn tại những phép toán phải được thực hiện với một thứ tự nhất định, có sự chia sẻ dữ liệu từ bước này sang bước khác, và không tạo đủ chức năng nếu không hoạt động cùng nhau. Ví dụ như là một hàm tính toán tuổi của nhân viên và thời gian nghỉ hưu, với tham số là ngày tháng năm sinh. Nếu hàm đó sử dụng tuổi để tính toán thời gian nghỉ hưu, nó đã có sự gắn kết theo tuần tự. Nếu hàm đó tính toán tuổi và thời gian nghỉ hưu trong hai phép tính toán tách biệt nhau, nó sẽ chỉ có sự gắn kết nhờ giao tiếp.
	\item Sự gắn kết nhờ giao tiếp: Xảy ra khi các phép toán trong hàm sử dụng cùng dữ liệu mà không liên quan đến nhau theo bất cứ một cách nào. Chẳng hạn như một hàm in ra một báo cáo và sau đó khởi tạo lại giá trị của nó. Hai phép toán thao tác trên cùng một dữ liệu nhưng không liên quan gì tới nhau. 	
	\item Sự gắn kết tạm thời: Xảy ra khi một vài các phép toán được tổng hợp vào một hàm bởi vì chúng thực hiện cùng thời điểm. Ví dụ thông thương đó là các hàm như $startup()$, $shutdown()$, $create\_new\_employee()$.
	\item Sự gắn kết hướng thủ tục: Xảy ra khi những phép toán trong một hàm được thực hiện theo một thứ tự nhất định. Một ví dụ là một hàm lấy tên của nhân viên, địa chỉ, và rồi số điện thoại. Thứ tự của những phép toán này chỉ quan trọng bởi vì nó khớp với thứ tự mà người sử dụng hỏi từ màn hình. Để đạt được sự gắn kết tốt hơn, đặt những phép toán riêng rẽ vào thành một hàm, đảm bảo rằng bạn gọi hàm đó với một mục đích là làm một việc đơn nhất. 
	\item Sự gắn kết theo logic: Xảy ra khi nhiều phép toán được nhồi vào cùng một hàm và chúng được lựa chọn nhờ vào một cờ điều khiển được truyền vào hàm. Chúng được gọi là gắn kết theo logic vì luồng điều khiển, hay "logic" là cái duy nhất buộc chúng lại với nhau -- thường là một lệnh if hay một switch case lớn. Nó không hẳn là bởi vì các phép toán liên quan với nhau một cách logic. 
	\item Sự gắn kết ngẫu nhiên: Xảy ra khi các phép toán trong hàm có thể thấy rõ ràng là không có liên quan gì với nhau. 
\end{itemize}
Gần như là luôn luôn có thể tạo các hàm gắn kết theo chức năng, vậy nên cố gắng tập trung vào gắn kết theo chức năng để đặt hiểu quả cao nhất. 


\subsubsection{KT7.4. The name of a routine is an indication of its quality. If the name is bad and it's accurate, the routine might be poorly designed. If the name is bad and it's inaccurate, it's not telling you what the program does. Either way, a bad name means that the program needs to be changed.}
Tên của một hàm, thủ tục sẽ chỉ định chất lượng của nó. Nếu tên của hàm là tồi và nó chính xác, hàm đó có thể đã được thiết kế kém. Nếu tên hàm đó là tồi và nó không chính xác, nó sẽ không nói cho bạn biết chương trình sẽ làm cái gì. Trong cả hai trường hợp, một tên tồi nghĩa rằng chương trình của bạn cần thay đổi.
\vspace*{3mm}

Một vài những chỉ dẫn khi muốn tạo một tên có hiệu quả: 
\begin{itemize}
	\item Mô tả mọi thứ mà hàm, thủ tục đó thực hiện: Ví dụ $compute\_report\_totals()$ không mô tả được rõ hàm đó thực hiện những gì. 
	\item Tránh những động từ vô nghĩa, không có nhiều tác dụng: Ví dụ như những hàm $handle\_calculation()$, $perform\_services()$.
	\item Tạo tên hàm dài nhất cần thiết: Tên một hàm trung bình là khoảng 15 đến 20 kí tự. 
	\item Để đặt tên một hàm có giá trị trả về, sử dụng mô tả của giá trị trả về: Ví dụ $current\_color()$, $is\_ready()$.
	\item Để đặt tên một hàm không có giá trị trả về (hay thủ tục), sử dụng một động từ mạnh theo sau là một thực thể. Ví dụ như $print\_document()$, $check\_order\_info()$. Trong ngôn ngữ hướng đối tượng, bạn không cần phải bao gồm cả tên thực thể theo sau động từ vì bản thân thực thể đã đi trước lời gọi hàm. Ví dụ như $document.print()$, $order\_info.check()$. Tên giống như $document.print\_document()$ là dư thừa và có thể dẫn đến không chính xác. Ví dụ $Check$ là một class kế thừa từ $Document$, $check.print()$ sẽ nghĩa in ra một thông tin kiểm tra nào đó, nhưng $check.print\_document()$ thì không được như vậy. 
	\item Sử dụng những từ trái ngược một cách chính xác. Ví dụ những cặp:
		\begin{itemize}
			\item $add$/$remove$
			\item $begin$/$end$
			\item $create$/$destroy$			
			\item $first$/$last$
			\item $get$/$set$
		\end{itemize}
	\item Thành lập các quy ước cho các phép toán phổ biến. Ví dụ như:
\begin{python}
employee.id.get()
dependent.get_id()
supervisor()
candidate()
\end{python}
	Là trường hợp mà một cách lấy id mà có nhiều phương pháp khác nhau. Gây ra những sự khó chịu, nhầm lẫn không đáng có.

\end{itemize}

\subsubsection{KT7.5. Functions should be used only when the primary purpose of the function is to return the specific value described by the function's name.}
Hàm có giá trị trả về nên được sử dụng khi mục đích chính của nó là trả về một giá trị cụ thể được mô tả bởi tên hàm đó.
\vspace*{3mm}

\noindent {\bfseries Một vài những xem xét khi sử dụng hàm có giá trị trả về:}
\begin{itemize}
	\item Khi nào thì sử dụng hàm có hoặc không có giá trị trả về (hoặc thủ tục):
		Hàm nên thuần tuý chỉ trả về một giá trị, giá trị đó là phép tính toán mà hàm đó thực hiện. Có nghĩa là hàm chỉ nhận những tham số và trả về giá trị thông qua tên hàm đó mà thôi. Tên của hàm sẽ luôn luôn được đặt cho giá trị trả về của nó. Một hàm không có giá trị trả về (hay thủ tục) thì ngược lại, có thể nhận đầu vào, chỉnh sửa và xuất ra nhờ tham số. Một thực tế phổ biến là một hàm có thể hoạt động như một thủ tục nhưng lại có giá trị trả về. Một cách logic, nó giống một thủ tục (hàm không có giá trị trả về) nhưng vì nó trả về giá trị, nó chính thức là một hàm. Ví dụ như:
\begin{python}
if report.format_output(formatted_report) == SUCCESS:
	...
\end{python}
		Một cách thay thế cho những hàm này là:
\begin{python}
report.format_output(formatted_report, output_status)
if output_status == SUCCESS:
	...
\end{python}
	\item Thiết lập giá trị trả về cho hàm: Sử dụng hàm tạo một rủi ro rằng hàm đó sẽ trả về giá trị không chính xác. Nó thường xảy ra khi hàm có một vài phần mà một trong số đó không đặt giá trị trả về.
	\begin{itemize}
		\item Kiểm tra toàn bộ những khả năng trả về. Khi tạo hàm, xem xét đầy đủ các trường hợp có thể để đảm bảo rằng hàm trả về những giá trị đã được định trước. 
		\item Đừng trả về tham chiếu hoặc con trỏ tới một giá trị trong hàm. 
	\end{itemize}


\end{itemize} 

\subsubsection{KT7.6. Careful programmers use macro routines with care and only as a last resort.}
Lập trình viên cần sử dụng hàm macro một cách cẩn thận và chỉ sử dụng khi nó là phương án cuối cùng. 
\vspace*{3mm}

Trong C, nếu bạn sử dụng macro, hãy lưu ý những điều sau:
\begin{itemize}
	\item Đặt các câu lệnh trong macro luôn luôn đi kèm với dấu ngoặc đơn. 
	\item Đặt một macro nhiều câu lệnh trong cặp dấu ngoặc nhọn. 
	\item Đặt tên macro giống như hàm để mà nó có thể thay thế bằng hàm khi cần thiết. 
\end{itemize}
Sử dụng hàm macro có nhiều hạn chế. Như Bjarne Stroustrup, người thiết kế ra ngôn ngữ C++ nói rằng “Almost every macro
demonstrates a flaw in the programming language, in the program, or in the
programmer.... When you use macros, you should expect inferior service from
tools such as debuggers, cross-reference tools, and profilers” -- Gần như mọi macro thể hiện một lỗi hồng trong ngôn ngữ lập trình, trong chương trình, hoặc bên trong chính lập trình viên... Khi bạn sử dụng macro, bạn nên mong đợi vào dịch vụ cấp thấp của các công cụ như trình gỡ rối,  công cụ tham chiếu chéo, và những hồ sơ của chương trình. Macro hữu dụng cho việc hỗ việc biên dịch có điều kiện, nhưng một lập trình viên cẩn thận sẽ chỉ sử dụng macro như một cách thay thế cho hàm khi nó là phương án cuối cùng. 

\subsection{Sử dụng chương 8 – Các kỹ thuật bẫy lỗi và phòng ngừa lỗi -- Defensive Programming}
\noindent Các kĩ thuật tiêu biểu gồm:

\subsubsection{KT8.1.Production code should handle errors in a more sophisticated way than "garbage in, garbage out."}
Khi code như là một sản phẩm thương mại thì nó nên xử lý những lỗi một cách tinh vi hơn chỉ là việc "rác vào thế nào, rác ra như vậy".
\vspace*{3mm}

\noindent {\bfseries Bảo vệ chương trình của bạn từ những đầu vào không hợp lệ: }

Trong một phần mềm thương mại, việc "rác vào thế nào, rác ra như vậy"  không hề tốt. Một chương trình tốt sẽ không bao giờ để "rác đi ra", bất kể cái gì nó nhận vào. Một chương trình tốt sử dụng "rác vào, không gì xuất ra" hay "rác vào, thông báo lỗi xuất ra". Theo chuẩn ngày nay, "Rác vào thế nào, rác ra như vậy" đánh dấu cho một chương trình luộm thuộm, thiếu tính bảo mật. 

Có ba cách để xử lý "rác" vào chương trình của bạn:
\begin{itemize}
	\item Kiểm tra tất cả những giá trị của dữ liệu từ nguồn bên ngoài: ví dụ file, dữ liệu người dùng, mạng, hoặc một vài interface bên ngoài chương trình. 
	\item Kiểm tra giá trị của tất cả tham số vào hàm. 
	\item Quyết định xem làm thế nào để xử lý những giá trị đầu vào không hợp lệ.  
\end{itemize}
Ví dụ đơn giản về kiểm tra tham số đầu vào: 
\begin{python}
def is_prime(n):
	a = int(n) 	# make sure parameter is integer
	if a <= 1:
		return False
	for i in range(2, a):
		if a % i == 0:
			return False
	return True 
\end{python}


\subsubsection{KT8.2. Defensive-programming techniques make errors easier to find, easier to fix, and less damaging to production code.}
Kỹ thuật lập trình phòng thủ làm cho những lỗi xảy ra dễ dàng được tìm thấy, được sửa chữa và gây hại ít hơn chương những đoạn code của chương trình. 

\subsubsection{KT8.3. Assertions can help detect errors early, especially in large systems, high-reliability systems, and fast-changing code bases.}
Assertion - "Sự tuyên bố" có thể giúp phát hiện những lỗi sớm, đặc biệt trong một hệ thống lớn, độ tin cậy cao, thường xuyên thay đổi mã nguồn. 
\vspace*{3mm}

Một assertion là những dòng code được sử dụng trong khi phát triển phần mềm -- 	thông thường nó là một hàm hoặc một macro -- Cái mà cho phép chương trình được kiểm tra bản thân nó khi chạy. Khi một assert đúng, không có gì xảy ra. Khi nó sai, nó báo hiệu rằng một lỗi không mong đợi đã xảy ra. Assertion thực sự hữu dụng trong những chương trình lớn, phức tạp, độ tin cậy cao. Nó cho phép lập trình viên nhanh chóng tìm ra những sai sót, những thứ không phù hợp trong giả định của interface đang dùng, những lỗi xảy ra khi thay đổi code. 

Assertion có thể được sử dụng để kiểm tra những giả định sau: 
\begin{itemize}
	\item Những tham số đầu vào có giá trị rơi vào khoảng xác định.
	\item File được mở (đóng) khi hàm bắt đầu thực hiện (hoặc khi kết thúc). 
	\item Con trỏ file được đặt đúng vị trí khi bắt đầu (hoặc kết thúc) đọc file. 
	\item File là chỉ đọc, chỉ ghi, hay cả đọc cả ghi. 
	\item Con trỏ là khác NULL.
	\item Giá trị của biến đầu vào không bị thay đổi bởi hàm. 
	\item Một array hoặc một kiểu dữ liệu chứa đựng có ít nhất số phần tử lớn hơn mức nào đó. 
	\item Cái cấu trúc dữ liệu chứa đựng là trống rỗng (hoặc đầy) trước khi hoặc kết thúc hàm.
	\item ...
\end{itemize}
Như hàm ở kĩ thuật phía trên, ta sử dụng assert:
\begin{python}
def is_prime(n):
	assert(isinstance(n, int))
	assert(n >= 2)
	for i in range(2, n):
		if n % i == 0:
			return False
	return True 
\end{python}

\subsubsection{KT8.4 The decision about how to handle bad inputs is a key error-handling decision and a key high-level design decision.}
Những quyết định về cách làm thế nào xử lý những đầu vào không hợp lệ là những quyết định chủ đạo trong việc xử lý lỗi và công việc thiết kế ở mức cao. 
\vspace*{3mm}

Bảo vệ hàm, chương trình của bạn khỏi những đầu vào không hợp lệ là bước đầu tiên và quan trọng nhất trong việc tránh những lỗi quan trọng xảy ra trong chương trình. Nó sẽ thúc đẩy những quyết định của bạn trong thiết kế hệ thống ra sảo để đảm bảo an toàn, từ đó tăng độ bảo mật cho chính hệ thống. 

\subsubsection{KT8.5. Exceptions provide a means of handling errors that operates in a different dimension from the normal flow of the code. They are a valuable addition to the programmer's intellectual toolbox when used with care, and they should be weighed against other error-processing techniques.}
Những ngoại lệ cung cấp một cách thức xử lý lỗi mà trong đó hoạt động của nó xảy ra ở một chiều khác so với dòng chảy thông thường của code. Chúng là một công cụ thông minh, đầy giá trị của lập trình viên khi biết sử dụng nó cẩn thận, và chúng nên được xem xét sử dụng nhiều hơn so với các kỹ thuật xử lý lỗi khác. 
\vspace*{3mm}

\noindent {\bfseries Những lưu ý khi sử dụng exception:}
\begin{itemize}
	\item Sử dụng ngoại lệ để thông báo phần khác của chương trình về những lỗi mà nó không nên bỏ qua.
	\item Throw một ngoại lệ chỉ khi mà điều kiện đó thực sự là điều kiện đặc biệt. 
	\item Đừng throw một ngoại lệ khi mà bạn có thể xử lý lỗi đó ngay trong hàm của mình. 
	\item Tránh throw một ngoại lệ ở trong constructor và destructor trừ khi bạn catch nó ở cùng một nơi. 
	\item Throw một ngoại lệ phải đúng mức trừu tượng. 
	\item Gom tất cả những thông tin dẫn đến ngoại lệ vào trong bản thân ngoại lệ đó. 
	\item Tránh tạo khối catch trống. 
	\item Biết về những ngoại lệ mà thư viện của bạn throw. 
	\item Xem xét về việc xây dựng một nơi báo cáo ngoại lệ tập trung. 
	\item Chuẩn hoá cách sử dụng ngoại lệ trong project của bạn. 
	\item Xem xét việc thay thế ngoại lệ bằng một cách khác. 
\end{itemize} 
Như ví dụ ở trên, ta thay thế nó bằng exception:
\begin{python}
def is_prime(n):
	if not isinstance(n, int):
		raise TypeError("n is not an integer")
	if n < 2:
		raise ValueError("n is less than 2")	
	
	for i in range(2, n):
		if n % i == 0:
			return False
	return True 
try:
	print(is_prime(1))
except TypeError as e:
	print("Type error exception!")
	print(e)
except ValueError as e:
	print("Value error exception!")
	print(e)
\end{python}

\subsubsection{KT8.6. Constraints that apply to the production system do not necessarily apply to the development version. You can use that to your advantage, adding code to the development version that helps to flush out errors quickly.}
Những ràng buộc áp dụng cho hệ thống được xuất ra thị trường không nhất thiết áp dụng cho phiên bản đang phát triển. Bạn có thể sử dụng những điều đó cho lợi thế của mình, thêm những code vào phiên bản đang phát triển của phần mềm sẽ giúp cho bạn nhanh chóng tìm ra những lỗi xảy ra với hệ thống. 
\vspace*{3mm}

Phiên bản xuất ra thị trường phải chạy nhanh, nhưng phiên bản để phát triển có thể chạy chậm. Phiên bản hoạt động thực tế có thể rất khắt khe khi xử dụng tài nguyên, phiên bản đang phát triển có thể sử dụng cực kì nhiều tài nguyên. Phiên bản xuất ra không nên xuất hiện những phương thức gây hại cho hệ thống, phiên bản phát triển có thể có những phương thức thêm vào mà không đảm bảo độ an toàn. 

\end{document}
